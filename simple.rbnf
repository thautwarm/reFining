import std.common.[Name Space Number DoubleQuotedStr Comment]
pyimport refining.reunify.[*]
ignore [Space]

SingleQuote := R'\''
keyword cast := 'let' 'in' 'type' 'fn' 'of' 'rec'

operator_have_to_pre_announce := '=>'


Sym ::= Name as n
        rewrite Id(n.value)


Str ::= DoubleQuotedStr+ as seq
        rewrite
            Const(''.join(e.value for e in seq))

Num ::= Number as num
        rewrite
            Const(int(num.value))

Let ::=
    | 'let' Name as tag [':' Type as annotate] '=' Expr as value 'in' Expr as do
    rewrite
        Let(tag.value, annotate, value, do)

Expr ::= | Let as v
         | App as v
         rewrite v

App  ::= Atom+ as seq
         rewrite
            head, *tail = seq
            if tail:
                for e in tail:
                    head = App(head, e)
            head

Lam ::= 'fn' Sym as sym [':' Type as annotate] '->' Expr as ret
         rewrite
            Lam(sym, annotate, ret)


NestedExpr ::=
        | '(' Expr as head (',' Expr)* as tail [',' as mark] ')'
        | '(' ')'
        rewrite
            unit if not head else\
            (Tuple((head, ))
                if mark else head) if not tail else\
            Tuple((head, *tail[1::2]))


Atom ::= | NestedExpr as v [':' Type as ty]
         | Num as v  [':' Type as ty]
         | Sym as v  [':' Type as ty]
         | Str as v  [':' Type as ty]
         | Lam as v  [':' Type as ty]
         rewrite Annotate(v, ty) if ty else v


Type    ::= | ComposedType as composed
            | '(' Type     as nested ')'
            rewrite
                composed if composed else\
                nested   if nested   else\
                TypeInduct(TypeSym(name.value), args) if args else\
                TypeSym(name.value) if name else\
                TypeSlot(undecided.value)

ComposedType
        ::= | FunctionType as head ('*' FunctionType)* as tail
            rewrite
                TypeJoin((head, *tail[1::2])) if tail else head

FunctionType
        ::= AtomType as arg ['=>' AtomType as ret]
        rewrite
            TypeFunction(arg, ret) if ret else arg

AtomType
        ::= | '(' Type     as nested ')'
            | Name as name ['of' Type as args]
            | SingleQuote Name as undecided
            rewrite
                TypeInduct(TypeSym(name.value), args) if args else\
                TypeSym(name.value) if name else\
                TypeSlot(undecided.value)



TypeDef ::= 'type' Name as name ['of' Type as induct_arg] '=' Type as expand
            rewrite
                TypeDef(TypeInduct(TypeSym(name.value), induct_arg), expand) \
                if induct_arg else TypeAbbr(name.value, expand)


Stmt ::= | Expr    as v
         | TypeDef as v
         rewrite v

Grammar  ::= (Stmt [';'])+ as seq
            rewrite
                Stmts(tuple(e for e in seq if Eq in e.__class__.__mro__))
