import std.common.[Name Space Number DoubleQuotedStr Comment]
pyimport refining.reunify.[*]
ignore [Space]

SingleQuote := R'\''
keyword cast := 'let' 'in' 'type' 'fn' 'of' 'rec'

operator_have_to_pre_announce := '=>'


Sym ::= Name as n
        rewrite Id(n.value)


Str ::= DoubleQuotedStr+ as seq
        rewrite
            Const(''.join(e.value for e in seq))

Num ::= Number as num
        rewrite
            Const(int(num.value))

Let ::=
    | 'let' Name as tag [':' Type as annotate] '=' Expr as value 'in' Expr as do
    rewrite
        Let(tag.value, annotate, value, do)

Expr ::= | Let as v
         | App as v
         rewrite v

App  ::= Atom+ as seq
         rewrite
            head, *tail = seq
            if tail:
                for e in tail:
                    head = App(head, e)
            head

Lam ::= 'fn' Sym as sym [':' Type as annotate] '->' Expr as ret
         rewrite
            Lam(sym, annotate, ret)


NestedExpr ::=
        | '(' Expr as head (',' Expr)* as tail [',' as mark] ')'
        | '(' ')'
        rewrite
            unit if not head else\
            (Tuple((head, ))
                if mark else head) if not tail else\
            Tuple((head, *tail[1::2]))


Atom ::= | NestedExpr as v [':' Type as ty]
         | Num as v  [':' Type as ty]
         | Sym as v  [':' Type as ty]
         | Str as v  [':' Type as ty]
         | Lam as v  [':' Type as ty]
         rewrite Annotate(v, ty) if ty else v


Type    ::=
            | Type as head '=>' as fn Type as tail
            | Type as head '*'  as tp Type as tail
            | '(' Type as nested ')'
            | Name as name ['of' Type as args]
            | SingleQuote Name as undecided
            rewrite

                TypeFunction(head, tail) if fn else\
                TypeJoin(head, tail) if tp else\
                nested if nested else\
                TypeInduct(TypeSym(name.value), args) if args else\
                TypeSym(name.value) if name else\
                TypeSlot(undecided.value)


TypeDef ::= 'type' Name as name ['of' Type as induct_arg] '=' Type as expand
            rewrite
                TypeDef(TypeInduct(TypeSym(name.value), induct_arg), expand) \
                if induct_arg else TypeAbbr(name.value, expand)


Stmt ::= | Expr    as v
         | TypeDef as v
         rewrite v

Grammar  ::= (Stmt [';'])+ as seq
            rewrite
                Stmts(tuple(e for e in seq if Eq in e.__class__.__mro__))
